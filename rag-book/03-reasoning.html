<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>reasoning – Hamel's Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-473cd3fdae26158324e3fa026112ebdf.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-5c21931d6ed7008fd1b1d77c416f53fd.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZSZXL3KFR5"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-ZSZXL3KFR5', { 'anonymize_ip': true});
</script>
<!-- Custom head content for all pages -->
<meta name="msvalidate.01" content="F9BFAF34FB8220973415C67CA60EB1A0">
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-PKGWQMKL');</script>
<!-- End Google Tag Manager -->


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="Hamel’s Blog">
<meta property="og:description" content="A collection of blogs and talks on machine learning and data science.">
<meta property="og:image" content="https://hamel.dev/notes/llm/rag/p3-images/slide_2.png">
<meta property="og:site_name" content="Hamel's Blog">
<meta property="og:image:height" content="2250">
<meta property="og:image:width" content="4000">
<meta name="twitter:title" content="Hamel’s Blog">
<meta name="twitter:description" content="A collection of blogs and talks on machine learning and data science.">
<meta name="twitter:image" content="https://hamel.dev/notes/llm/rag/p3-images/slide_2.png">
<meta name="twitter:creator" content="@HamelHusain">
<meta name="twitter:site" content="@HamelHusain">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="2250">
<meta name="twitter:image-width" content="4000">
</head>

<body class="nav-fixed quarto-dark"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = true;
    const queryPrefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    const darkModeDefault = queryPrefersDark.matches;
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    queryPrefersDark.addEventListener("change", e => {
      if(window.localStorage.getItem("quarto-color-scheme") !== null)
        return;
      const alternate = e.matches
      toggleColorMode(alternate);
      localAlternateSentinel = e.matches ? 'alternate' : 'default'; // this is used alongside local storage!
      toggleGiscusIfUsed(alternate, darkModeDefault);
    });
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" target="_blank"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../notes/index.html" target="_blank"> 
<span class="menu-text">Notes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://parlance-labs.com/" target="_blank"> 
<span class="menu-text">Hire Me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../oss/opensource.html" target="_blank"> 
<span class="menu-text">OSS</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../talks.html" target="_blank"> 
<span class="menu-text">Teaching</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
            <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#optimizing-retrieval-with-reasoning-models" id="toc-optimizing-retrieval-with-reasoning-models" class="nav-link active" data-scroll-target="#optimizing-retrieval-with-reasoning-models">Optimizing Retrieval with Reasoning Models</a>
  <ul class="collapse">
  <li><a href="#llm-capabilities-instruction-following-and-reasoning" id="toc-llm-capabilities-instruction-following-and-reasoning" class="nav-link" data-scroll-target="#llm-capabilities-instruction-following-and-reasoning">LLM Capabilities: Instruction Following and Reasoning</a></li>
  <li><a href="#the-search-paradigm-hasnt-changed" id="toc-the-search-paradigm-hasnt-changed" class="nav-link" data-scroll-target="#the-search-paradigm-hasnt-changed">The Search Paradigm Hasn’t Changed</a></li>
  <li><a href="#evolution-of-search-paradigms" id="toc-evolution-of-search-paradigms" class="nav-link" data-scroll-target="#evolution-of-search-paradigms">Evolution of Search Paradigms</a></li>
  <li><a href="#understanding-instructions-in-ir" id="toc-understanding-instructions-in-ir" class="nav-link" data-scroll-target="#understanding-instructions-in-ir">Understanding Instructions in IR</a></li>
  <li><a href="#introducing-promptriever-and-rank1" id="toc-introducing-promptriever-and-rank1" class="nav-link" data-scroll-target="#introducing-promptriever-and-rank1">Introducing Promptriever and Rank1</a></li>
  <li><a href="#promptriever-instruction-trained-retrieval" id="toc-promptriever-instruction-trained-retrieval" class="nav-link" data-scroll-target="#promptriever-instruction-trained-retrieval">Promptriever: Instruction-Trained Retrieval</a></li>
  <li><a href="#promptriever-evaluation-results" id="toc-promptriever-evaluation-results" class="nav-link" data-scroll-target="#promptriever-evaluation-results">Promptriever Evaluation Results</a></li>
  <li><a href="#rank1-reasoning-based-reranking" id="toc-rank1-reasoning-based-reranking" class="nav-link" data-scroll-target="#rank1-reasoning-based-reranking">Rank1: Reasoning-Based Reranking</a></li>
  <li><a href="#rank1-performance-results" id="toc-rank1-performance-results" class="nav-link" data-scroll-target="#rank1-performance-results">Rank1 Performance Results</a></li>
  <li><a href="#finding-novel-relevant-documents" id="toc-finding-novel-relevant-documents" class="nav-link" data-scroll-target="#finding-novel-relevant-documents">Finding Novel Relevant Documents</a></li>
  <li><a href="#chapter-takeaways" id="toc-chapter-takeaways" class="nav-link" data-scroll-target="#chapter-takeaways">Chapter Takeaways</a></li>
  <li><a href="#video" id="toc-video" class="nav-link" data-scroll-target="#video">Video</a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/hamelsmu/hamel-site/edit/master/rag-book/03-reasoning.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>

<!-- Content inserted at the beginning of body tag -->
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PKGWQMKL" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->




<section id="optimizing-retrieval-with-reasoning-models" class="level1">
<h1>Optimizing Retrieval with Reasoning Models</h1>
<p><em>Based on a presentation by Orion Weller</em></p>
<p><a href="https://orionweller.github.io/" target="_blank">Orion Weller</a> from Johns Hopkins University focuses on embedding the instruction-following and reasoning capabilities of modern Large Language Models (LLMs) directly into the retrieval process.</p>
<p>In his talk, Orion argues that while LLMs have improved RAG, the core retrieval step has remained static. He introduces a paradigm where instruction-following and reasoning are baked directly into retrieval models, a fundamental shift from using LLMs for query rewriting or as generic rerankers.</p>
<section id="llm-capabilities-instruction-following-and-reasoning" class="level2">
<h2 class="anchored" data-anchor-id="llm-capabilities-instruction-following-and-reasoning">LLM Capabilities: Instruction Following and Reasoning</h2>
<p><img src="../notes/llm/rag/p3-images/slide_2.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=18s">Timestamp: 00:00:18</a>)</em></p>
<p>The talk begins by highlighting the user-facing interfaces of modern LLMs like ChatGPT, which have set new expectations for how we interact with AI. One key capability of LLMs is <strong>instruction following</strong>: executing complex, multi-part natural language instructions with high fidelity.</p>
<p><img src="../notes/llm/rag/p3-images/slide_4.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=36s">Timestamp: 00:00:36</a>)</em></p>
<p>Orion shows the result of a pirate-themed haiku prompt. The model successfully adheres to all constraints: it generates a haiku, maintains a pirate style, and mentions “RAG,” demonstrating a level of instruction following that is a recent and significant advancement.</p>
<p><img src="../notes/llm/rag/p3-images/slide_5.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=58s">Timestamp: 00:00:58</a>)</em></p>
<p>A second key capability is <strong>reasoning</strong>, also known as test-time compute or “thinking.” The slide shows a model verbalizing its thought process to solve a problem, generating intermediate “thinking tokens” that outline its step-by-step logic before providing the final answer.</p>
</section>
<section id="the-search-paradigm-hasnt-changed" class="level2">
<h2 class="anchored" data-anchor-id="the-search-paradigm-hasnt-changed">The Search Paradigm Hasn’t Changed</h2>
<p><img src="../notes/llm/rag/p3-images/slide_7.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=112s">Timestamp: 00:01:52</a>)</em></p>
<p>To illustrate how little the search paradigm has changed, Orion shows Google’s interface from 1999.</p>
<p><img src="../notes/llm/rag/p3-images/slide_8.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=118s">Timestamp: 00:01:58</a>)</em></p>
<p>He contrasts it with a modern Google search bar. Despite 26 years of development, the fundamental interaction remains the same: a user types keywords, and the system matches them to return a list of links.</p>
<p><img src="../notes/llm/rag/p3-images/slide_11.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=166s">Timestamp: 00:02:46</a>)</em></p>
<p>Despite the interface, Orion argues the underlying retrieval process has not evolved. Even in advanced systems, the LLM is often just a “wrapper.” The system sends the query to a traditional search engine, gets back a standard list of results, and then uses the LLM to summarize them. The retrieval step itself hasn’t gained the new capabilities of the LLM.</p>
</section>
<section id="evolution-of-search-paradigms" class="level2">
<h2 class="anchored" data-anchor-id="evolution-of-search-paradigms">Evolution of Search Paradigms</h2>
<p><img src="../notes/llm/rag/p3-images/slide_14.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=238s">Timestamp: 00:03:58</a>)</em></p>
<p>To illustrate current limitations, Orion starts with <strong>Keyword Search</strong>, which relies on exact lexical matching. Given a query and three documents, keyword search matches “Data Encryption Standards” and “Wolves Outside Your Data” because they contain the keyword “data.”</p>
<p>It fails to retrieve “Digital Protection” because it lacks the keyword “data,” even though “digital” is semantically similar.</p>
<p><img src="../notes/llm/rag/p3-images/slide_16.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=251s">Timestamp: 00:04:11</a>)</em></p>
<p>The next evolution is <strong>Semantic Search</strong>, which matches based on meaning, often by representing queries and documents as vectors in a shared semantic space. A good semantic search model would retrieve all three documents, as it understands the relationship between “data” and “digital,” and “privacy” and “protection.”</p>
<p><img src="../notes/llm/rag/p3-images/slide_20.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=325s">Timestamp: 00:05:25</a>)</em></p>
<p>Orion introduces <strong>Instruction-based Search</strong>, where the query is a nuanced command. The user wants to find documents about data privacy that also use “extended metaphors.”</p>
<p>An instruction-based search system should understand this meta-level constraint and retrieve only the “Wolves Outside Your Data” document, which uses a metaphorical title. It correctly identifies that the other two documents, while topically relevant, do not meet the stylistic instruction.</p>
<p><img src="../notes/llm/rag/p3-images/slide_21.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=376s">Timestamp: 00:06:16</a>)</em></p>
<p>Orion pushes the concept to its extreme with <strong>Prompt and Reasoning-based Search</strong>. The query now includes instructions about the desired <em>behavior</em> of the search engine, such as “Have really high recall or I will lose my job.”</p>
<p>A traditional search engine would misinterpret this, likely searching for documents containing the word “recall.” An advanced, reasoning-based retriever should understand the user’s intent and adjust its retrieval strategy.</p>
</section>
<section id="understanding-instructions-in-ir" class="level2">
<h2 class="anchored" data-anchor-id="understanding-instructions-in-ir">Understanding Instructions in IR</h2>
<p><img src="../notes/llm/rag/p3-images/slide_25.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=402s">Timestamp: 00:06:42</a>)</em></p>
<p>What is an instruction in the context of IR? Orion breaks it down into several categories:</p>
<ul>
<li><strong>Document attributes</strong> like date, length, or source</li>
<li><strong>NLU aspects</strong>, such as document sentiment or writing style<br>
</li>
<li><strong>Logical conditions</strong>, combining multiple constraints with operators like AND, OR, and NOT</li>
</ul>
<p>The space of possible instructions mirrors the complexity of natural language.</p>
</section>
<section id="introducing-promptriever-and-rank1" class="level2">
<h2 class="anchored" data-anchor-id="introducing-promptriever-and-rank1">Introducing Promptriever and Rank1</h2>
<p><img src="../notes/llm/rag/p3-images/slide_32.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=465s">Timestamp: 00:07:45</a>)</em></p>
<p>Orion introduces two models from his research that embody these principles:</p>
<ol type="1">
<li><strong>Promptriever</strong>: A fast embedding model for following instructions during initial retrieval</li>
<li><strong>Rank1</strong>: A powerful but slower reranker that uses reasoning and test-time compute for nuanced relevance judgments</li>
</ol>
</section>
<section id="promptriever-instruction-trained-retrieval" class="level2">
<h2 class="anchored" data-anchor-id="promptriever-instruction-trained-retrieval">Promptriever: Instruction-Trained Retrieval</h2>
<p><img src="../notes/llm/rag/p3-images/slide_34.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=503s">Timestamp: 00:08:23</a>)</em></p>
<p>Orion explains the two main retrieval architectures. A <strong>Bi-Encoder</strong> (dense retriever) creates separate query and document embeddings for fast comparison, making it highly scalable. A <strong>Cross-Encoder</strong> (reranker) processes the query and document together for deeper interaction at a higher computational cost. Promptriever is a bi-encoder.</p>
<p><img src="../notes/llm/rag/p3-images/slide_36.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=550s">Timestamp: 00:09:10</a>)</em></p>
<p>The main research question was how to enable fast, scalable bi-encoders to understand complex instructions. The missing ingredient was <strong>training data</strong>. Existing retrieval datasets like MSMARCO lack instructions because users don’t type them into traditional search engines.</p>
<p><img src="../notes/llm/rag/p3-images/slide_39.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=607s">Timestamp: 00:10:07</a>)</em></p>
<p>This slide illustrates the process of generating the training data, starting with a standard query. The process uses an existing query-document pair from a standard dataset and uses an LLM to generate a detailed <strong>instruction</strong> that makes the relevance criteria more specific. A crucial part was also generating <strong>instruction negatives</strong> - documents that are relevant to the query but irrelevant to the <em>instruction</em>.</p>
</section>
<section id="promptriever-evaluation-results" class="level2">
<h2 class="anchored" data-anchor-id="promptriever-evaluation-results">Promptriever Evaluation Results</h2>
<p><img src="../notes/llm/rag/p3-images/slide_48.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=756s">Timestamp: 00:12:36</a>)</em></p>
<p>On FollowIR, the baseline RepLLaMA (and all prior embedding models) scored negatively, performing <em>worse</em> when given an instruction. Promptriever is the first to achieve a positive score, demonstrating that bi-encoders can learn to follow instructions.</p>
<p><img src="../notes/llm/rag/p3-images/slide_57.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=838s">Timestamp: 00:13:58</a>)</em></p>
<p>Without a prompt, Promptriever performs comparably to the RepLLaMA baseline, showing that instruction-following capabilities don’t hurt performance on traditional tasks.</p>
<p><img src="../notes/llm/rag/p3-images/slide_58.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=853s">Timestamp: 00:14:13</a>)</em></p>
<p>When a generic instruction is added, Promptriever’s performance increases significantly, while the baseline’s degrades slightly. This demonstrates that Promptriever’s retrieval strategy can be controlled with natural language - a form of <strong>zero-shot hyperparameter optimization via prompting</strong>.</p>
</section>
<section id="rank1-reasoning-based-reranking" class="level2">
<h2 class="anchored" data-anchor-id="rank1-reasoning-based-reranking">Rank1: Reasoning-Based Reranking</h2>
<p><img src="../notes/llm/rag/p3-images/slide_67.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=968s">Timestamp: 00:16:08</a>)</em></p>
<p>The focus now shifts to Rank1, the reasoning-based model. The associated paper’s title is “Rank1: Test-Time Compute for Information Retrieval,” highlighting its focus on reasoning in the reranking stage.</p>
<p><img src="../notes/llm/rag/p3-images/slide_73.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=1028s">Timestamp: 00:17:08</a>)</em></p>
<p>This slide shows what the reasoning process looks like in information retrieval. Given a query and a document, the model generates a detailed reasoning trace, identifying key phrases, analyzing the relationship between query and document, and questioning its own interpretations before arriving at a final judgment.</p>
<p><img src="../notes/llm/rag/p3-images/slide_76.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=1130s">Timestamp: 00:18:50</a>)</em></p>
<p>This slide shows Rank1’s reasoning on a LeetCode problem. Asked to find a similar problem, it correctly identifies the core “two-pointer approach” algorithm in the provided document and recognizes that the candidate document also uses the same technique, demonstrating a deep, algorithmic level of understanding.</p>
</section>
<section id="rank1-performance-results" class="level2">
<h2 class="anchored" data-anchor-id="rank1-performance-results">Rank1 Performance Results</h2>
<p><img src="../notes/llm/rag/p3-images/slide_80.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=1178s">Timestamp: 00:19:38</a>)</em></p>
<p>The evaluation covers tasks testing reasoning (BRIGHT), negation (NevIR), and instruction following (mFollowIR). The baseline model, RankLLaMA, was trained on <strong>10 times more data</strong> than Rank1. Despite being trained on far less data, Rank1 nearly doubles the performance of the baseline on the BRIGHT reasoning benchmark.</p>
<p><img src="../notes/llm/rag/p3-images/slide_84.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=1216s">Timestamp: 00:20:16</a>)</em></p>
<p>To isolate the impact of the reasoning chain, they compared training the same model on the same data, with and without the “thinking” part of the training examples. The results show that training the model to generate the reasoning chain leads to a massive 10-point gain in performance. The act of “thinking” itself unlocks these advanced capabilities.</p>
</section>
<section id="finding-novel-relevant-documents" class="level2">
<h2 class="anchored" data-anchor-id="finding-novel-relevant-documents">Finding Novel Relevant Documents</h2>
<p><img src="../notes/llm/rag/p3-images/slide_87.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=1244s">Timestamp: 00:20:44</a>)</em></p>
<p>They were surprised by low scores on the DL19/DL20 datasets, discovering their model was finding many documents that had never been judged by human annotators because older systems had never retrieved them.</p>
<p><img src="../notes/llm/rag/p3-images/slide_91.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=1299s">Timestamp: 00:21:39</a>)</em></p>
<p>Reasoning-based models are not just improving scores on old benchmarks; they are <strong>finding new, relevant documents</strong> that previous systems missed. This also suggests the IR community should move on from older evaluation datasets as they may not be equipped to measure modern model capabilities.</p>
</section>
<section id="chapter-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="chapter-takeaways">Chapter Takeaways</h2>
<p><img src="../notes/llm/rag/p3-images/slide_97.png" class="img-fluid"></p>
<p><em>(<a href="https://youtu.be/YB3b-wPbSH8?t=1357s">Timestamp: 00:22:37</a>)</em></p>
<p>Orion concludes that the overall goal is to create IR systems that work like LLMs, capable of handling queries that combine topic, style, and behavioral instructions.</p>
<p>Key insights from this work:</p>
<ol type="1">
<li><strong>Promptriever</strong> enables fast bi-encoder retrievers to follow complex instructions through specialized training data</li>
<li><strong>Rank1</strong> uses reasoning chains to achieve superior performance on complex retrieval tasks</li>
<li>Both models demonstrate that LLM capabilities can be successfully integrated into retrieval systems</li>
<li>Reasoning-based models discover novel relevant documents that traditional systems miss</li>
</ol>
<p>New retrievers can directly benefit from rapid LLM advancements. As LLMs get better at reasoning and instruction following, so will the retrieval systems built upon them.</p>
</section>
<section id="video" class="level2">
<h2 class="anchored" data-anchor-id="video">Video</h2>
<p>Here is the full video:</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/YB3b-wPbSH8" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/hamel\.dev\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/hamelhusain/">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/HamelHusain">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/hamelsmu">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/hamelsmu/hamel-site/edit/master/rag-book/03-reasoning.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>